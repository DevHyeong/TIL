# 3장 코드에서 나는 악취

## 기이한 이름
- 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기처럼 이름을 바꾸는 리팩터링들이다. 이름만 잘 지어도 문맥을 파악하느라 헤매는 시간을 절약할 수 있다.

## 중복 코드

## 긴 함수
- 코드를 이해하고 공유하고 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다. (함수 이름에 코드의 목적을 드러내야 한다.)

## 긴 매개변수 목록
- 적용할 리팩터링 기법: 매개변수를 질의 함수로 바꾸기, 객체 통째로 넘기기, 매개변수 객체만들기, 플래그 인수 제거하기, 여러 함수를 클래스로 묶기(공통 값들을 클래스의 필드로 정의)

## 전역 데이터
- 적용할 리팩터링 기법: 변수 캡슐화하기

## 가변 데이터
- 적용할 리팩터링 기법: 변수 캡슐화하기, 변수 쪼개기 등

## 뒤엉킨 변경
- 딘일 책임 원칙이 제대로 지켜지지 않을때 나타난다. 즉 하나의 모듈이 서로 다른 이유로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.

## 산탄총 수술
- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.

## 기능 편애
- 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 풍기는 냄새다.
- 이럴 때는 함수가 데이터와 가까이 있고 싶어 한다는 의중이 뚜렷이 드러나므로 데이터 근처로 옮겨주면 된다.(함수 옮기기) 핵심은 함께 변경할 대상을 한데 모으는 것이다
- 전략 패턴과 방문자 패턴을 적용하면 오버라이드해야 할 소량의 동작 코드를 각각의 클래스로 격리해주므로 수정하기가 쉬워진다.(대신 간접호출이 늘어난다.)

## 데이터 뭉치
- 데이터 뭉치인지 판별하려면 값 하나를 삭제해보자. 그랬을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.

## 기본형 집착
- 자신에게 주어진 문제에 딱 맞는 기초 타입(화폐, 좌표 등)을 직접 정의하기를 몹시 꺼리는 사람이 많다.
- 이 냄새는 문자열을 다루는 코드에서 특히 흔하다. 전화번호를 단순히 문자 집합으로만 표현하기엔 아쉬움이 많다. 최소한 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이라도 갖춰야 한다.

## 반복되는 switch문
- 적용할 리팩토링 기법: 조건부 로직을 다형성으로 바꾸기

## 반복문
- 적용할 리팩토링 기법: 반복문을 파이프라인으로 바꾸기

## 성의 없는 요소

## 추측성 일반화
- 이 냄새는 나중에 필요할거야라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다.

## 임시 필드
- 간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 하지만 객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는게 보통이다.
- 적용할 리팩토링 기법: 클래스 추출하기, 함수 옮기기, 특이케이스 추가하기

## 메시지 체인
- 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.
- ex) aPerson.department.manager.name
- 적용할 리팩토링 기법: 위임 숨기기

## 중개자
- 객체의 대표적인 기능 하나로 외부로부터 세부사항을 숨겨주는 캡슐화가 있다. 캡슐화하는 과정에서 위임이 자주 활용된다. 하지만 지나치면 문제가 된다. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 중개자를 제거하고 직접 소통하도록 수정하자.

## 내부자 거래
- 소프트웨어 개발자는 모듈 사이에 벽을 두껍게 세우기를 좋아하며 모듈 사이의 데이터 거래가 많으면 결합도가 높아진다고 투덜댄다. 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.
- 적용할 리팩토링 기법: 함수 옮기기, 필드 옮기기, 위임 숨기기 등
