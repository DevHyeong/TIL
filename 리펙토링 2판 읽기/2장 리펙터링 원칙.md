# 2장 리팩터링 원칙

## 리팩터링 정의
- 소프트웨어의 겉보기 동작은 그대로 유지한 채 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

## 두 개의 모자
- 소프트웨어를 개발할 때 목적이 기능 추가냐 아니면 리팩터링이냐를 명확히 구분해 작업한다. 켄트 벡은 이를 두 개의 모자에 비유했다.
- 소프트웨어를 개발하는 동안 두 모자를 자주 바꿔 쓴다. 새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들기도 하는데 그러면 잠시 모자를 바꿔쓰고 리팩터링한다.

## 리팩터링하는 이유
- 리팩터링하면 소프트웨어 설계가 좋아진다.
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
- 리팩터링하면 버그를 쉽게 찾을 수 있다.
- 리팩터링하면 프로그래밍 속도를 높일 수 있다.

## 언제 리팩터링해야 할까?
### 준비를 위한 리팩터링
- 리팩터링하기 가장 좋은 시점은 코드베이스에 새 기능을 새로 추가하기 직전이다. 이 시점에 현재 코드를 살펴보면서 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.
- 버그를 잡을 때도 마찬가지다. 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다.

### 이해를 위한 리팩터링
- 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.
- 코드가 깔끔하게 정리되어 전에는 보이지 않던 설계가 눈에 들어오기 시작한다. 코드를 분석할 때 리팩터링을 해보면 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

### 쓰레기 줍기 리팩터링
- 코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다. 이때 약간 절충해야 한다. 간단히 수정할 수 있는 것은 즉시 고치고 시간이 걸리는 일은 짧은 메모만 남긴 다음 하던 일을 끝내고 나서 처리한다.

### 계획된 리팩터링과 수시로 하는 리팩터링
- 개발에 들어가기 전에 리팩터링 일정을 따로 잡아두지 않고 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다. 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다.
- 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

## 리팩터링 시 고려할 문제
- 누가 특정한 기술, 도구, 아키텍처 등을 내세울 때마다 항상 문제점을 찾는다. 무언가를 언제 어디에 적용할지 판단하려면 손익을 제대로 이해해야 한다.

### 새 기능 개발 속도 저하
- 리팩터링의 궁극적인 목적은 개발 속도를 높여서 더 적은 노력으로 더 많은 가치를 창출하는 것이다.
- 건강한 코드의 위력을 충분히 경험해보지 않고서는 코드베이스가 건강할 떄와 허약할 때의 생산성 차이를 체감하기 어렵다.
- 리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경게적인 이유로 하는 것이다. 리팩터링은 개발 기간을 단축하고자 하는 것이다. 기능 추가 시간을 줄이고 버그 수정 시간을 줄여준다.

### 코드 소유권
- 리팩터링하다 보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다. 클라이언트가 사용하는 공개된 인터페이스라면 기존 함수는 유지하되 함수 본ㅎ문에서 새 함수를 호출하도록 수정한다.

### 브랜치
- 기능 브랜치 방식: 팀원마다 코드베이스의 브랜치를 하나씩 맡아서 작업하다가 결과물이 어느 정도 쌓이면 마스터 브랜치에 통합해서 다른 팀원과 공유하는 것이다.
- 기능 브랜치 방식에는 단점이 있다. 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다. 이 고통을 줄이고자 많은 이들이 마스터를 개인 브랜치로 수시로 리베이스하거나 머지한다. 하지만 여러 기능 브랜치에서 동시에 개발이 진행될 때는 이런 식으로 해결할 수 없다.
- 머지: 마스터를 작업 브랜치로 가져오는 단방향 작업, 통합: 마스터를 개인 브랜치고 가져와서 작업한 결과를 다시 마스터에 올리는 양방향 처리
- 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다. 이 방식을 지속적 통합(CI) 또는 트렁크 기반 개발(TBD)이라 한다.
- CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다. 이를 위해서는 마스터를 건강하게 유지하고 거대한 기능을 잘게 쪼개는 법을 배우고 각 기능을 끌 수 있는 기능 토글(피쳐플래그)을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.
- 머지의 복잡도를 줄일 수 있어서 CI를 선호하기도 하지만 가장 큰 이유는 리팩터링과 궁합이 좋기 때문이다.

### 테스팅
- 리팩터링을 하기 위해서는 자가 테스트 코드를 마련해야 한다.

### 레거시 코드
- <레거시 코드 활용 전략>에서는 '프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다'는 것이다. 이러한 틈새를 만들 때 리팩터링이 활용된다. 테스트 없이 진행하기 때문에 상당히 위험하지만 문제를 해결하기 위해서라면 감내해야 할 위험이다.

## 리팩터링, 아키텍처, 애그니(YAGNI)
- 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 단, 이 요구를 멋지게 해결하도록 설계한다. 진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다.
- 이러한 식으로 설계하는 방식을 간결한 설계, 점진적 설계, YAGNI(You Aren`t Going to Need It) 등으로 부른다.
- YAGNI: 필요한 작업만 해라, 프로그램을 작성하다 보면 현재는 사용하지 않지만 확장성을 고려해서 미리 작업해 놓은 것들이 있다. 그런 작업을 하지말라는 원칙이다. 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 훨씬 낫다.

## 리팩터링과 소프트웨어 개발 프로세스
- 애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다.
- 리팩터링의 첫 번째 토대는 자가 테스트 코드다. 다시 말해 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다.

## 리팩터링과 성능
- 직관적인 설계 vs 성능
- 리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.
- 리팩터링은 성능 좋은 소프트웨어를 만드는데 기여한다. 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있다. 하지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬어지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다.
