# 2024년 10월 한달

## 2024-10-09
-

## 2024-10-10
#### 김영한님 JPA 읽기
- 13장 웹 어플리케이션과 영속성 관리
- 14장 컬렉션과 부가기능(리스너까지)
#### 내용 정리
- 트랜잭션과 영속성 컨텍스트는 밀접한 관계다. 트랜잭션의 범위 안이어야 엔티티가 영속 상태가 되며 범위 밖으로 벗어나면 준영속 상태가 된다. 준영속 상태가 되면 지연 로딩시에 프록시 초기화 에러가 발생하여 데이터를 가져오지 못한다.
- 트랜잭션은 보통 서비스 계층에서 시작하고 끝이 나게 되는데 프리젠테이션 계층에서는 지연 로딩을 어떻게 활용할 수 있을까?
- 이 책에서는 다양한 방법을 제시하고 있지만 엔티티를 프리젠테이션 계층까지 노출하지 않고 DTO를 정의하여 데이터를 제공하는게 좋은 방법이라고 생각한다. (책에서도 언급하지만 물론 이 방법은 엔티티와 유사한 수많은 DTO가 생기게 된다.)
- 새롭게 알게된 건 스프링이 제공하는 OSIV다. 기본적으로 필터/인터셉터부터 데이터 계층까지 영속성 컨텍스트를 유지하고 서비스계층에서 트랜잭션이 시작/종료(커밋/롤백)되도록 지원한다고 한다. 즉 서비스 계층 이외의 범위에서는 엔티티 조회만 가능하다.(영속성 컨텍스트를 유지하기 때문,)
- 하지만 트랜잭션이 서비스 계층에서 시작/종료하므로 수정은 일어나지 않는다. 하지만 개인적인 생각으로는 엔티티를 프리젠테이션 계층까지 노출하는건 안티패턴?이라고 생각한다.

## 2024-10-16
#### [헥사고날 아키텍처를 통한 의미 수준과 구현 수준에 대한 이해](https://mangkyu.tistory.com/396) 읽기
- 소프트웨어 설계 관점에서 의미 수준과 구현 수준 사이에는 언제나 간극이 존재할 수 있다. 따라서 우리가 구현을 할 때에도 이에 대한 고민을 항상 함께 하고, 올바른 가치 판단을 내릴 수 있어야 한다.
- 소프트웨어 설계에는 정답이 없고 맞고 틀림이 없다. 대신 중요한 것은 왜 이러한 의사 결정과 가치 판단을 내렸는지에 대한 명확한 근거이다.
- 실용주의적 사고로 가치 판단을 내리는 경우가 많은데, 이러한 생각의 기저에는 “개발자라면 비즈니스에 기여해야 한다”는 관점이 있기 때문이다.
#### 김영한님 JPA 읽기
- 엔티티 리스너 등록(@EntityListener)
- 엔티티 그래프: 실제로 사용할 일이 없을 것 같아서 제외
- 15장 고급 주제와 성능 최적화
  - 예외처리: PersistenceExceptionTranslationPostProcessor를 통해 jpa 예외 -> 스프링 예외로 변환(장점: 서비스 계층에서 jpa 예외에 의존적 x)
  - 엔티티 비교: 트랜잭션 범위에 따른 엔티티 컨텍스트 영향 (동등성, 동일성, 식별자)
  - 프록시 심화 주제: 

## 2024-10-17
#### 15장 고급 주제와 성능 최적화
##### 상속관계와 프록시
- 프록시를 부모 타입으로 조회하면 문제가 발생한다.
- 프록시를 부모 타입으로 조회하는 문제는 주로 다형성을 다루는 도메인 모델에서 나타난다.
- 해결방안: JPQL로 대상 직접 조회, 프록시 벗기기, 기능을 위한 별도의 인터페이스 제공, 비지터 패턴 사용

## 2024-10-18
#### 성능최적화(15장)
- N+1 문제 -> 페치 조인 사용
- 읽기 전용 쿼리 성능 최적화: 영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관하므로 더 많은 메모리를 사용하는 단점이 있다. (@Transactional(readOnly=true))
- 트랜잭션을 지원하는 쓰기 지연과 성능 최적화: IDENTITY 식별자 생성 전략일 경우 쓰기 지연 최적화를 할수 없다.
